\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}

\title {Functional and logic programming lab 5th report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle

解いた順番で考察を書いたため、順番が前後しています。すいません。Q1-Q7まで全て解いていて、Q5だけ一番最後に記述しています。

Q1-Q4は4というディレクトリにまとめています。

Q5は5というディレクトリに実装しています。このディレクトリでQ6,Q7の機能も実装できています。
Q6は6というディレクトリに実装しています。
Q7は7というディレクトリに実装しています。

また、Q5とQ7ではQ6までで作った部分を壊したりしたので、別で提出しています。


\section{Q.1: example.mlの実行}
\subsection{動作例と考察}

1. ocamlyacc parser.mly

この操作によって、parser.mlとparser.mliが作られる。

ocamlyaccでは、トークン列から抽象構文木にしている。文法を木にしている。
ここでは、parser.mly を受け取って、parser.mlとparser.mliを作っている。

parser.mlyの中のarith_exprをexprにすると、当然だが、文法の規則の優先順位がわからなくなり、reduce/reduce conflictが起こる。

ocamlyaccの出力のもう一つ、parser.outputには、オートマトンの各状態に対するものが記載されている。
次に何がくるとreduceをして、何がくるとshiftをするかなどが記載されている。

\vspace{12pt}

2. ocamllex lexer.mll

この操作で、lexer.mlが作られる。これはプログラムから字句解析器が作られている。lexer.mllには、プログラムを単なる文字列とみて、その文字一つ一つに対して、どうしていくのかが記載されている。

\vspace{12pt}

3. ocamlc –c syntax.ml

syntax.mlから実行ファイル(.cmoと.cmi)が作られる。syntax.mlには、関数の型が記載されている。

\vspace{12pt}

4.ocamlc –c parser.mli
ocmalc –c parser.ml

parserに対する実行ファイルの作成。


\vspace{12pt}


5. ocamlc -c lexer.ml

3-5をこの順番で行う理由は依存関係による。

プログラムが、字句解析器（5でコンパイルしたもの）を通って、トークン列となり、

トークン列が、構文解析器（４でコンパイルしたもの）を通って、抽象構文木となり、

抽象構文木にしたがって、計算するプログラム（3でコンパイルしたもの）を介して、評価が行われるからである。

\vspace{12pt}
6.ocamlc –c example.ml

実際に処理を行うプログラムの作成。これは標準出力と標準入力を先ほどコンパイルしたプログラムたちと繋げている。

\vspace{12pt}

7. ocamlc –o example syntax.cmo parser.cmo lexer.cmo example.cmo

ここでも依存関係を気にしなければならない。


\section{Q2: 引き算、乗算、除算の定義}

\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # 3-2;;
  - = 1
  # 2 * 3;;
  - = 6
  # 6/2;;
  - = 3
\end{lstlisting}

\subsection{考察}
変えるべきところは、eval.mlだけであった。

lexer.mllの中で、-, *, / についてのプログラムの認識はすでに作られており、parserの中でそれに対する優先順位と構文木はすでに書かれており、syntax.mlでそれに対する型も書かれていた。

本来ならば、上記全てを変える必要がある。

eval.mlでは、expr型とexpr型をもらって評価結果を返せば良い。

expr型を評価するときの環境は現在の環境である。

\section{Q3: let文の定義}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let x = 3 in
    x + 3;;
    - = 6
  # let x = 4;;
    x = 4
  # x + 2;;
    - = 6
  #let x = 2 in
   let y = x + 2 in
   y + 3;;
   - = 7
\end{lstlisting}

\subsection{考察}


今回の実装についても、eval.mlの部分を実装するだけで十分であった。なぜなら、その他の部分については、すでに配布資料で実装が行われていたからである。

let in 文についてはELetで実装し、let文については、CDeclで実装した。
ELetの処理については、eval\_exprの中で定義されていて、CDeclの処理については、eval\_commandの中で定義されている。

eval\_exprでは、評価結果の値(value型)のみを返し、eval\_commandでは、「変数名、新しい環境、評価結果」を返す。このうち、変数名と、評価結果は標準出力に出力される。

よって、let in文は新しい環境を返す必要がない上に、let in文の中の変数は、標準出力に出してはいけないので、eval\_exprで定義するべきである。

let文は逆に、eval\_commandで定義するべきである。

letin文についての実装は以下のようになっていて、
$$eval\_expr (extend \; e1 \; (eval\_expr  \; env \; e2) \; env) \;e3$$
let x = 3 in x+3;;では、e1にx、e2に3、e3にx+3が対応している。

$(eval\_expr \; env \; e2)$で、e2のexpressionを評価して、value型にする。ここで、昔の環境を使っていることに注意する。この値を環境に加えたものを$(extend \; e1 \; (eval\_expr  \; env \; e2) \; env)$で作り、そのもとで、e3を評価している。

let分についての実装は以下のようになっていて、
$$ CDecl (e1,e2) -> (e1,\; (extend \; e1 \;(eval\_expr \; env \; e2) env),\; eval\_expr \; env \; e2)$$
let x = 4;;ではxがe1に、4がe2に対応している。

eval\_commandで返す第一要素には、変数名を返せば良いので、e1を返している。

eval\_commandで返す第二要素には、新しい環境を返せば良いので、$
(extend \; e1 \;(eval\_expr \; env \; e2) env)$を返している。
ここで、変数の評価は、元の環境を使って行なっていることに注意する。

第三要素は、評価結果を返せば良い。


\section{Q4: Boolの計算}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # true && true;;
    - = true
  # true && false;;
    - = false
  # false || true;;
    - = true
  # false || false;;
    - = false
  # false || if 1 = 1 then false else true;;
  - = false
  # true && let x = true in x;;
  - = true
  # false || 1 = 1;;
  - = true
\end{lstlisting}

\subsection{考察}

まず、lexer.mllで、$&&$と$||$に対するtokenを定義して、parser.mlyで文法を定める。
そして、syntax.mlで型を定め、eval.mlでどのように評価するのかを定める。

boolの演算については、評価の順番に気をつけなくてはならない。動作例の最後の三つから分かるように、評価はlet文やif文よりも後に行われる。すなわち、構文木においては、上の方で早めに分岐させなければならない。

Eval.mlのEqやLtもboolが定義できるように変えている。

\section{Q6: let文を同時に定義できるような実装}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
# let x = 10
  let y = x+1
  let z = x*y;;
  x = 10
  y = 11
  z = 110
# let x = true
  let y = false
  let z = x && y;;
  x = true
  y = false
  z = false
\end{lstlisting}

\subsection{考察}

let文を連続して入力できるようにした。

新たにletexpressionというのを定義して、再帰的にevaluationを行えるようにした。

この時、型に関して、letexpressionはcommand型であることに注意する。

eval.mlのなかの、LLetの評価については、環境を更新しつつ新しい変数を評価しなければならないので、let in文を用いて書いている。この時、eval\_command関数を再帰的に定義させる必要がある。

出力するまでに値を覚えておく必要があったので、command型の第一要素と第三要素に変更を加えた。具体的にはリストとして働くようにした。それに応じて、標準出力と対応させているmain.mlの部分も、リストから出力できるように変更を加えた。

\section{Q7: let and 文を定義できるような実装}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let x = 2 and y = 4 and z = 3;;
  x = 2
  y = 4
  z = 3
  # x;;
  - = 2

  # let x = 10;;
  x = 10
  # let x = 50
  and y = x * 2;;
  x = 50
  y = 20

  # let x = 10;;
  x = 10
  # let x = 50
  and y = x * 2
  in x + y;;
  - = 70
\end{lstlisting}

letandについてはQ6のlet文の環境が保存されないものであるので、Q6の実装を少し変えることと、let andのためのletandexpressionという非終端記号を作れば良い。通常のlet文との区別を行うために、toplevelでandが入るか否かの判定を行なっている。letandのために作成した関数は、AndLetのみである。これは再帰的に呼び出されるものである。


また、inの扱いについては、再考しなければならず、構文木の変更を行った。
inの前は評価されないことに着目し、inbeforeというinの前にくるlet文のための非終端記号を作成した。
InEvalという関数は、inbeforeで定義された型を元に関数の評価を行うものである。

このInEvalという実装のため、eval\_exprに環境を返して欲しかったため、type valueの中に(name * value) listを作成した。

それを踏まえて、let and in文のために、TempList とTempListAddを作成した。

TempListはinの前の文で作られる環境を一時的に保存しておくリストを作るもので、TempListAddはそれに新たに加えていく関数である。

InEvalは、eval\_exprで受け取った環境に、現在の環境をappendした環境で、評価を行うという操作を行えば良い。

\vspace{12pt}

\section{Q5: エラー処理}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # a;;
  Error: Unbound value a
  # 1 + true;;
  Error: This expression has type bool but an expression was expected of type
           int
  # let x = ?;;
  Unknown Token: ?
  # let x = 2 and let z = 3;;
  parse error near characters 14-17
  #

\end{lstlisting}

\subsection{考察}
まず、例外が発生してもinterpreterが終了しないようにするために、main.mlを改良する。

interpreterが終了しないようにするためには、try文を使えばよく、try文で「構文解析器、字句解析器、評価器」の部分を囲えば良い。

評価器のエラーについては、raise EvalErrとしているので、try文のwithでEvalErrに対応するものを作れば良い。

字句解析器と構文解析器のエラーについては、failwithで処理を行っているため、try文のwith以下でFailureに対応するものを作れば良い。

以上のことをすると、例外が発生してもinterpreterが終了しないようにすることができる。

\vspace{12pt}

次に、Error出力について、評価器のエラーは、match文のそれぞれについてエラー出力を行えば良い。Ocamlのエラーコードをそれぞれ見ることで実装を行った。

構文解析器のエラーはデフォルトで実装されていたものを使用し、字句解析器のエラーについては、何文字目でおかしいのかを表示できるようにした。




\end{document}
