\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}
\renewcommand{\lstlistingname}{Code}

\title {Functional and logic programming lab 13th report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle

\section{実装について}
\subsection{全体の概要}
今回の実装では、大きく分けて三つの操作を行った。
(1,2)に準ずる場所という書き方をしている箇所は(1,2),(2,1),(1,7),(7,1),(8,7),(7,8),(2,8),(8,2)のことを表している。

\subsubsection{定石の導入}
https://skatgame.net/mburo/logistello.tar.gz　のリンクにある、logistelloという定石を導入した。この作業は友人と行った。まず、logistello同士の対戦のlogの最初の20手を取得し、その盤面を出力する。それをint64のpairにして、csv fileにする。csv fileは白の盤面(64bit整数),黒の盤面(64bit整数),次に打つべき座標、というデータとなっている。
対局データはd3から始まるものしか存在しなかったため、対称移動したものについてもデータに加えた。

int64に整形して入れた理由は、hash化した時の探索が行いやすい形にするためである。
同時にboardからint64のpairを生成するgenerate\_bit\_from\_board関数も実装した。
これで現在のboardをint64に変換し、hash tableから検索する。

play関数が初めて呼び出された時に、hashに値を追加する。Hashtblというlibrary関数を用いた。

create\_hash関数はhashとtext fileを受け取って、text fileの中に記述されているデータをhash tableにいれる関数である。一回めのloopに入った時に、この関数を呼ぶ。対戦データ盤面を同一のhash tableに入れても問題がなかったため、同一のhash tableに入れた。

各場所での然るべき操作に入る前に、このhash tableをみて、もしデータが入っていれば、探索などをおこなわず、これに決める。

\subsubsection{探索}
探索についてはmin-max法をbaseに用いた。min-max以外にも、色を変えてmaxを撮り続ける実装などを行ったが、min-maxが一番強かったため、min-maxを採用した。

approximate関数を用いて、n手先の予測を行った。まずvalid\_moves関数を用いて、合法的な手をリストにして出力し、その中の最適手を出力する。最適手のせんたくには、decide関数を用いる。decideでは、value\_approximate関数を用いて、その関数値がもっともよかった手を選ぶものとなっている。

value\_approximate関数では、n-1手先を読む作業を行う。

\subsubsection{枝刈り}
この読む作業については、alpha-beta法を用いた。alpha-beta法を実現するために、value\_approximate関数の引数にaccを渡し、比べて、その木を切ることができれば、切れるように工夫した。こうすることで、alpha-beta法が完成する。

また、alpha-beta法で探索を行うと同時に、探索を行うboardの順番もsortした。まず、一番初めの読み、すなわち、decide関数内で、value\_approximateの初めのcaseとなるboardについては、２手先までの評価でsortした。それ以外については、合法手の数が少ない順でsortした。

他にももっと深く探索を行う方法や、毎回探索を行う方法も実装してみたが、あまり早くならなかったため、この実装に至った。

\subsubsection{評価関数}
評価関数は序盤と中盤と終盤に分けて作成した。

序盤については、着手可能数と盤面評価で評価関数を実装した。
盤面評価については、端から１つ内側の列について低い値を当てて、盤面の中心に高い評価値を当てた。端については取れればとるようにしたいため、端にも正の評価値を当てた。そして、コマについてのその評価値の平均をとった。

着手可能数については、自分の打てる数を調べた。valid\_movesで合法手のlistを作り、その長さを求めた。

係数については両方の効果が現れるように係数を調整した。

\vspace{12pt}

中盤については、盤面評価関数と確定石の個数で評価した。
盤面評価については、
(2,2)と(1,2)、そしてそれに準ずる場所についての評価値を低く設定した。また、端の評価値を大きくして、端の隣の列を低くし、真ん中の値を正の値にとった。

確定石の個数についてはkakuteiという関数を用いて実装した。
kakutei関数では4端から2方向に、合計8方向、順に辿っていく。途中で被ってしまうが、係数をつければ関係ないので、途中での被って数えてしまうことは気にせず実装した。端から続いているかどうかの判定はflagを用いて行った。

この２つの関数を係数を調整して評価関数を作成した。係数については序盤と同じく、両方の影響が現れる係数比にした。

\vspace{12pt}

終盤については、評価関数を自分の石の数にして先読みを行うことで読み切りを実装した。終盤は評価関数の計算が軽く、合法手の数が少ないため、10手先を読むように工夫した。

評価関数はcount関数を用いた。これは自分の石の数を数える関数である。終盤は数を取りに行く。


\section{Play関数の中身について}
上記工夫を行ったplay関数について記述する。

9手以下については定石を確認して、なければ、序盤の評価関数を用いて６手読みを行う。

10〜13手については、定石を確認して、なければ、序盤の評価関数を用いて4手読みを行う。

14〜24手については、中盤の評価関数を用いて4手先読みを行う。

25手以降については終盤の評価関数を用いて10手先読みを行う。

\section{このオセロのコードについて}
\subsection{強い点}
このオセロは自分から危険な場所に置かないようになっている。というのも、delete\_dangerで端の隣に置かないようになっているからである。他の人と違ってここで明記しておき、候補から外しておくことで、自ら相手に端を渡すことをしなくなっている。負けに繋がるような手をあまり打たないため、randomとは100戦100勝が可能である。

相手の盤面の評価値を見ると、序盤は良い戦いをしていると思われた。

\subsection{弱い点}
また、オセロAIの特徴でもあるが、中盤の読みが強い。https://github.com/uhyo/is-othello を用いて、自分のAIオセロと戦ったが、(1,2)を置かないため、(1,2) - (1,7)を占領されてしまうという弱点があった。

また、お互いに、(1,2)に準ずる場所、(2,2)に準ずる場所を譲り合った場合、粘り負けしてしまうという弱点があった。相手が６手先を読んでいる場合に顕著であった。この場所で６手読むという戦略も考えたが、候補手が大きくなってしまうため、時間は最後の読み切りの方に使うことにした。

相手の評価値を見ると、終盤の読み切りになった段階で相手の評価値が上がった。やはり、読み手の少なさがあだになってしまっているようである。

定石データはハッシュの容量を気にして、20手までしか取らなかったが、思っていたよりスムーズにfindなどが行えたため、もう少し多くの手数をとってもよかったと感じた。実際、同じ定石を入れていた友人はより効果的に定石を使えていた。



\end{document}
