\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}
\renewcommand{\lstlistingname}{Code}

\title {Functional and logic programming lab 9th report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle

課題1,2,3を1-3という名前のfolderにまとめて実装した。

\section{Q.1-Q.3: 組・リスト}
\subsection{解答}
\begin{lstlisting}[caption=動作例]
Pair
# (2,3);;
int*int
- = (2,3)
# (2,true);;
int*bool
- = (2,true)
# (2,(true,false));;
int*bool *bool
- = (2,(true,false))

list
# [];;
a1list
- = []

# 1::[];;
intlist
- = VCons
# 2::(true::[]);;
Error = Unmatched type
# true :: (false :: (false :: []));;
bool list
- = VCons


# let a = match 1 with 1 -> 2 | 2 -> 1;;
int
a = 2
# let a = match 1 with 1 -> 2 | 2 -> true;;
Error = Unmatched type
# let a = match 1 with 1 -> 2 | true -> false ;;
Error = Unmatched type


\end{lstlisting}

\subsection{考察}
\subsubsection{Q1の考察}
まず、Q1について考察する。Q1はPairと空リストとconsについて実装する課題である。まず、Syntax.mlもtype expressionにPairを表すEPairと空リストを表すENilと、consを表すEConsの型を追加した。また、value型にも同様に、VPair、VNil、VConsを追加した。それに応じて、tySyntax.mlの中のPrint\_typeも変更した。

最後にeval.mlのeval\_exprで、追加したexpressionに対する評価を記述する。EPairがきた場合は、VPairの一つ一つに対する評価を行えば良い。

VPair((eval\_expr env e1),(eval\_expr env e2))。
EConsについても同様で、ENilについてはVNilを返せば良い。

\subsubsection{Q2の考察}
次に、Q2について考察する。Q2では、Pattern matchの評価を行えるようにした。

match文を表現するexpressionのEMatchを新たに定義した。

まず、Patternの照合を行う関数、find\_match関数を定義する。これはPatternと照合する値を受け取って、成功すれば追加する環境を返し、失敗すればNoneを返す関数である。この関数を使ってmatch文を評価する。

次に、eval\_exprの中について説明する。matchさせるexpressionをまず評価する。また、search\_matchという、先ほど定義したfind\_matchをpatternそれぞれについて行う関数を定義した。

ここでは前のパターンから順に照合させていき、最後まで照合に成功しなければEValErrをraiseする。パターンの照合に成功すれば、結果を環境に追加して、expressionを評価する。

\subsubsection{Q3の考察}
最後に、Q3について考察する。Q3では型推論を行なった。

まず、pairの型推論について考察する。Pairはそれぞれの要素を評価して、その評価の家庭で出てきた制約のunionを取れば良い。Consの型推論については、要素として追加する第一要素をlistにしたものは第二要素のlistの型と一致している必要がある。よってその制約と、式の評価途中の制約をunionすれば良い。

EMatchについての型推論を行う。

そのために、まず、find\_match\_typeという関数を作った。この関数は、パターンを受け取って、パターンの型と制約と追加される型環境を返す関数である。この関数の作成はスライド通りに行った。注意すべきは変数パターンとconsパターンである。変数パターンでは新しい型変数\alphaを導入して、それを型環境に追加しなければならない。consパターンでは、新しい変数を導入して、、制約にlistの肩が等しいということを追加しなければならない。

本題のinfer\_exprについて考察する。まず、matchの前の型と制約を求める。これをv1とする。そして、新しい型変数newvarを導入する。各パターンについて、find\_match\_patternを実行して、パターンpi,制約Ci,追加される環境\Gamma iを求める。

環境(この環境はinferし始めた時の環境)を\Gamma iで拡張した後、パターンに紐づけられているexpressionを型推論する。それをviとする。そして、$(union [(newvar, (fst(vi)))] (union [((fst(v1)), ti)](union (snd(vi)) (union ci const))))$として、制約を拡張していくことを繰り返す。(v1 とviが混同しやすいのでもう一度記述すると、v1はmatch文のwithの前のexpressionの評価結果で、viは各パターンのexpressionの評価結果。)この繰り返しによって、スライドに書かれている制約を得ることができる。

最後に、unificationアルゴリズムを少し変更する。pairとlistについて要素同士の統合にunificationすればいいので、constraintSolver.mlのに記述したような実装になる。

以上の実装を行えば型推論が行われるようになる。






\section{Q.4: 名前呼び}
\subsection{解答}
実際に名前呼びが行われたかどうかを確認するため、EAddが呼ばれるとexpressionを出力するようにした。
以下の動作例には四つの場合を記した。

1) (fun x $\rightarrow$ x * x) (2 + 3) を名前呼びで実行した場合。

2)(fun x $\rightarrow$ x * x) (2 + 3)を値呼びで実行した場合。

3) fact(1+0)を名前呼びで実行した場合。

4) fact(1+0)を値呼びで実行した場合。

1)の場合と2)の場合を比べると、名前呼びで実行した場合に、(2+3)の計算が二度されていることがわかる。EAddが二回行われているからである。よって、名前呼びにすることに成功しているとわかる。

3)と4)を比べる。名前呼びで実行した場合では、nの値が調べられるたびにEAddが実行されている。これもまた、名前呼びに成功している証拠となっている。


\begin{lstlisting}[caption=動作例]
1) execute (fun x -> x * x) (2 + 3) in call by name
# (fun x -> x * x) (2 + 3);;
int
EAdd (2,3)
EAdd (2,3)
- = 25

2) execute (fun x -> x * x) (2 + 3) in call by value
# (fun x -> x * x) (2 + 3);;
int
EAdd (2,3)
- = 25

3)execute fact (0+1) in call by name
# let rec fact n = if n = 0 then 1 else n * fact(n-1) in fact (1 + 0);;
int
EAdd (1,0)
EAdd (1,0)
EAdd (1,0)
- = 1

4)execute fact (0+1) in call by value
# let rec fact n = if n = 0 then 1 else n * fact(n-1) in fact (1 + 0);;
int
EAdd (1,0)
- = 1

\end{lstlisting}

\subsection{考察}
値呼びにするために、再帰でない関数と再帰関数の文について実装を行なった。
\subsubsection{再帰でない関数}
Thunkを用いて実装を行なった。Thunkの型は、expr * envである。これは環境に入れることになり、環境の型は、(var * thunk) listである。まず、変数をどうevalすればいいかについて書く。変数が来た時は、変数に対応するthunkを探す。この時、thunkの中身は環境と式であることに注意する。値を返さなければならないので、この時に評価が行われる。thunkの中に入っている環境で、thunkの中の式を評価することを行えば良い。

次に、関数適用をどう行うかについて書く。e1 e2の形で関数適用が行われるとする。まず、e1を評価すると、e1は関数の式なので、VFunが出てくるはずである。それをVFun(x1,expr1,env\_thunk)とする。e2をthunkにする。そのさいの環境は元の環境であることに注意する。このthunkをthunk1とする。thunk1を関数の引数xに対応させる。(extend x1 thunk1 env\_thunk)がそれに当たる。そのもとで、expr1を評価すれば、名前呼びが実現できる。

\subsubsection{再帰関数}
まず、再帰関数の適用部分については、fの環境を拡張して、その環境で評価する値を評価すれば良い。今回の実装でこの新しい環境はnewenvとして定義した。

fにはThunkを対応させる。fは、今の環境でThunk(ERecFun(....))を評価したものとなる。ここのenvがなぜ今の環境で良いかというと、評価の時に環境の拡張を行えば良いからである。また、ここで新しくERecFunというものが追加された。ERecFunは、VRecFunをexpression型と紐づけるために新たに作成したものである。

最後にVRecFunをどのように評価するか説明する。今回の実装では、この部分で環境を拡張しているため、この部分が再帰関数を実現させる肝となっている。まず、thunk1という再帰関数closureを作成する。このclosureには再帰関数を表すERecFunとVRecFunに入っていたenv(env\_thunk)を入れている。
あとは、applyする引数部分を現在の環境で評価するclosureを作って環境に追加して評価すれば良い。

\section{Q.5: 必要呼び}
\subsection{動作例}
前問と同じく、EAddを呼び出した回数を測るために、EAddの部分でprint\_exprを行なった。
\begin{lstlisting}[caption=動作例]
# (fun x -> x * x) (2 + 3);;
int
EAdd (2,3)
- = 25
# let rec fact n = if n = 0 then 1 else n * fact(n-1) in fact (1 + 0);;
int
EAdd (1,0)
- = 1
\end{lstlisting}
このコードは、値呼びと同じEAddの呼び出し回数となっているので、必要呼びに成功しているであろうとわかる。

\subsection{考察}
必要呼びは名前呼びから少し変更するだけで実装できる。変更する点は以下の2点である。まず一つ目は、環境の型の変更。二つ目は、変数を評価するときに、式であれば評価を実行して、値を保存し直すことである。

環境の型を変更するのは、式と環境のpairであるdthunkと、値を同時に持ちたいからである。一度評価されたthunkがもう一度評価されることはない。よって型は

env = (name * dval ref) list and dval = DThunk of expr * env $\mid$ DVal of value

となる。

次に、変数評価についてであるが、変数xに対するdval refを環境から見つける。それをsearchedとして、searchedが値であればそのまま返し、searchedがthunkであれば、thunkの中身を評価して、環境を値に更新して、値を返すことをすれば良い。

以上の工夫を名前呼びに施すことで完成する。

\section{Q6: インタプリタの機能拡張}
\subsection{動作例}
前問と同じく、EAddを呼び出した回数を測るために、EAddの部分でprint\_exprを行なった。
\begin{lstlisting}[caption=動作例]
# let a = ref 2;;
val a : int ref {contents = 2}
# (!a);;
- : int ref = 2
# a := true;;
Error: This expression has type bool but an expression was expected of type int
# a := 3;;
- : int = 3
# a;;
- : int ref = {contents = 3}
# 1::2::[];;
- : intlist = [1;2]
\end{lstlisting}
\subsection{考察}
実装したものを順に書いていく。
\subsubsection{エラー処理}
エラー処理の改良を行なった。

まず、parserがエラーを起こした時にどの部分でエラーを起こしたのか表示してくれるようにした。これはparser.mlyの一部にエラーが起きた時の実装を行うことで実装ができた。

また、型エラーが起きた時に、どの型を予測していたのにどの型が来たのかという情報をだすようにした。Ocamlの記法に習ってThis expression has ...のように出力した。

次に、環境に指定された変数がなかった時に、Unbound errorが起きるが、その時にどの変数が足りないのか表示するようにした。

Errorの色の変更も行なった。色のコードを調べ、Printf.printf関数の中に、埋め込むことで色の変更ができる。

細かいことだが、Ocamlのversion表示も行うようにした。今回提出したinterpreterの出力はOcamlの出力にできる限り即している。

\subsubsection{list, consの出力}
こちらも出力の話になるが、listとconsの出力を行えるようにした。print\_listとprint\_valueを相互再帰で実装する。listは[]で囲わなければならないので、最初の[をprint\_valueで実装し、最後の]をprint\_listで実装した。

\subsection{refの実装}
referenceをinterpreterで解釈できるように実装した。
refとして実装したのは、let文によるreferenceの宣言、exclamation markによる、referenceのcontentsの取り出し、値の再代入の三つである。

まず、parserとlexerを変更する。上記三つの構文をそれぞれ、CRef, ERefSub, RefExcalimを実装した。

次に、referenceの型とreferenceを表すvalueを作る。それぞれ
TyRefとVRefである。VRefは値の再代入が行えるように、value refの型にした。

それぞれの実装について解説する。

まず、let文によるreferenceの宣言を表すCRefは、refに格納する値を評価して、そのあとに、それをVRefの中に入れて環境に追加すればよい。ここで、前までの実装と、値をprintする場所が異なっているが、これはOcamlの出力に即するために、contentsの部分を表示させる必要があったためである。

次に、代入を表すERefSubについて、環境の中から、VRefを探して来て、その値を変えればよい。値を変えることができるのは、環境に入れているのがreferenceであるからである。

ERefExclamについては環境から値を見つけて取ることをすればよい。

最後に、型検査が通るようにしなければならない。基本的にはTyRefの型として型環境に追加していけばよい。
ただ、値の再代入の時は注意が必要である。再代入する際にreferenceに入れられていたものと、代入するものの型が異なれば、型エラーを出すべきである。よってこれを制約に加えなければならないことに注意する。

以上のようにして、referenceを実装した。




\end{document}
