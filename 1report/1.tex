\documentclass[uplatex,12pt]{jsarticle}
\title {Functional and logic programming lab 1st report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle

\section {Q.3: Fix function}
\subsection {an example of operation}
sum\_to\_n 3;; $\rightarrow $ 6

is\_prime 1;; $\rightarrow $ false

is\_prime 12;; $\rightarrow $ false

is\_prime 13;; $\rightarrow $ true

gcd 12 6;; $\rightarrow $ 6




\subsection{Discussion}
\subsubsection{About fix function}
For example, in sum\_to\_n, fix function behaves as follows.

fix f 3 = f (fix f) 3

= 3 + fix f 2

= 3 + 2 +  f (fix f) 1

= 3 + 2 + 1 + (fix f) 0

= 3 + 2 + 1 = 6


Fix function is called as a Fixed-point-combinator.
Fix function expands as
$$fix  f=f(f(\ldots f(\text { fix } f) \dots))$$


which I used this time. This function is often defined as the recursive function in functional programming language that does not support recursion.


\section {Q.4: fold\_right and fold\_left}
\subsection {an example of operation}
fold\_right(fun x y $\rightarrow$ 2*x + y) [1;2;3] 3;; $\rightarrow$ 15

fold\_left(fun x y $\rightarrow$ 2*x + y) 3 [1;2;3];; $\rightarrow$ 35

\subsection{Discussion}
\subsubsection{Difference between tail recursion and general recursion}
Tail recursion is a special case of recursion where the calling function does not compute after the recursive call. Tail recursion can compute more efficiently than the general recursion. When we have a general recursion, we have to store the return address on the call stack before jumping to the called function. This means we perhaps need a long call stack. However, when we have tail recursion, as soon as we return from the recursive call we can immediately return it. This means we do not need a call stack. Tail recursion enables us to save a space.

\subsubsection{Difference between fold\_right and fold\_left}
There are two differences between them. Obvious difference between them is an order which they combine elements from the list. The other difference is that fold\_left is a tail recursive but fold\_right is not. When we want to use fold\_right to a very long list, we should reverse the list and use fold\_left.


\section {Q.5: Append and filter}
\subsection {an example of operation}
append [1;2;3;] [5;4;3;];; $\rightarrow$ int list = [1; 2; 3; 5; 4; 3]

filter (fun x $\rightarrow$ if(x = 0) then true else false) [1;0;2];; $\rightarrow$ int list = [0]

\subsection{Discussion}

\subsubsection{Append function}
Note that we cannot put an element into a list from the right. We have to put it from the left. In order to reach append function, we use recursive function. As I mentioned, we have to put an element from the left, so it is necessarily to split the first argument and leave the second as it is.

\subsubsection{Filter function}
It is also can be written in recursive function. In procedual programming, we would judge the each element one by one. In functional programming, we could do in the same way. If the element satisfies the given condition, let it add the rest list. That is all the filter function did.



\section {Q.6: Append function using fold\_right and fold\_left}

\subsection {an example of operation}
append\_left is an append function written with fold\_left and append\_right is an append function written with fold\_right
append\_left [1;2;3;] [4;5;6;];; $\rightarrow$ int list = [1; 2; 3; 4; 5; 6]

append\_right [1;2;3;] [4;5;6;];; $\rightarrow$ int list = [1; 2; 3; 4; 5; 6]

\subsection{Discussion}
\subsubsection{Difference between appned\_right and append\_left}
append\_right is easier to write because there is no need to reverse the list. However, append\_left is better in the long length list because fold\_left uses the tail recursion which is discussed in 2.2.1. As I mentioned, tail recursion does not need a call stack. General recursion, we have to store the return address every time the function called. This means that we need a call stack whose size is linear in the depth of the recursive calls. In functional programming, we should use tail recursion when we can use it.


\section {Q.7: Permutation function}

\subsection{an example of operation}
perm [1;2;3;];; $\rightarrow$

int list list = [[1; 2; 3]; [1; 3; 2]; [2; 1; 3]; [2; 3; 1]; [3; 1; 2]; [3; 2; 1]]


\subsection{Discussion}

\subsubsection{Function's flow (Algorithm)}
\begin{enumerate}
  \item Get an element (a) from the list
  \item Generate all permutations with the rest list.
  \item Put (a) on the top of the each permutations (This operation generates all the permutations that starts with (a))
  \item Do 1. - 3. with all the element of the list.
\end{enumerate}

\subsubsection{About the function in the code}
\begin{itemize}
  \item Filter
    \begin{itemize}
      \item This function behaves as filter function. This receives a condition and a list as an input. This function trashes the element of the list that is not satisfies the given condition. This function is used in order to create a list that does not include (a).
    \end{itemize}
  \item filterfunc
    \begin{itemize}
      \item This function behaves as map function that applies a given function to each element of a list. This function is used in order to realize 5.2.1.3. (put (a) on the top of the each permutations)
    \end{itemize}
\end{itemize}

\subsubsection{About the permutation function}
In order to realize the 5.2.1.4, I used the fold\_left function. Type of "acc" is a list of a list.



\section {Q.8: Reverse function}

\subsection{an example of operation}

reverse [1;2;3;];; $\rightarrow$ int list = [3; 2; 1]

reverse\_right [1;2;3;];; $\rightarrow$ int list = [3; 2; 1]

\subsection{Discussion}

\subsubsection{Reverse function}
In order to acheive the reverse function, inreverse function is created. Inreverse function is a function with three steps. First, this function takes one element from the first argument. Second, it connect the element and the second argument. Third, it calls the recursive function.
This function moves as follows.
\begin{enumerate}
  \item inreverse [1;2;3;] []
  \item inreverse [2;3;] [1;]
  \item inreverse [3;] [2;1;]
  \item inreverse [] [3;2;1;]
  \item return [3;2;1;]
\end{enumerate}

\subsubsection{Reverse function using fold\_right}
It is absolutely easy to create reverse function with fold\_left, because fold\_left operates from the top of the list. When we use fold\_right as the fold\_left, we should treat the element as a function.

Let $f (x, h) = h \circ x^*$ under $x^*$ be a function that connects $x$ with a given list, then we gain the following equation.
$$f (x_1,(f (x_2,e^*))) = f (x_1, (e^* \circ x_2^*)) = e^* \circ x_2^* \circ x_1^*$$

Let $e^*$ be an identity function, we could gain the reverse function. What is point is that treating the element as the function.

Plus, we should be careful that function composition of f ang g is not (f g x) in ocaml. (fun y $\rightarrow$ f y)(g x) is the correct sentense in ocaml.


\section {Q.9: fold\_r and fold\_l}

\subsection{an example of operation}
fold\_l\_using\_r (fun x y $\rightarrow$ 2*x + y) 3 [1;2;3:];;$\rightarrow$ 35

fold\_r\_using\_l (fun x y $\rightarrow$ 2*x + y) [1;2;3;] 3;;$\rightarrow$ 15

\subsection{Discussion}

The point is same as the Q.8.

let $e^*$ be an identity function, and $x^*$ be a function that receives e as an input and returns $f (e, x)$.

$$g (x_1, g(x_2,e^*))e = g(x_1,e^* \circ x_2^*)e = (e^* \circ x_2^* \circ x_1^*)e $$$$=e^*\circ x_2^*(f(e,x_1)) = e^*f(f(e,x_1),x_2)=f(f(e,x_1),x_2)$$

The above equation represents the way to express fold\_l woth fold\_r


\section {Q.10: define add, mul, sub}

\subsection{an example of operation}
add (fun f x $\rightarrow$ f x) (fun f x $\rightarrow$ f (f x)) (fun y $\rightarrow$ y + 1) 0;; $\rightarrow$ int = 3

mul (fun f x $\rightarrow$ f x) (fun f x $\rightarrow$ f (f x)) (fun y $\rightarrow$ y + 1) 0;; $\rightarrow$ int = 2

minus (fun f x $\rightarrow$ f (f x)) (fun f x $\rightarrow$ f x) (fun y $\rightarrow$ y + 1) 0;; $\rightarrow$ int = 1


\subsection{Discussion}
This is called Church encoding.
add and mul function is easy to write.
In order to make minus function, I created the pred function. Pred function receives n as input and return n-1 as an output.

(fun $ g,h \rightarrow h(g f) )$ in my code runs again and again. This "h" becomes id funciton only the last time. It achieve the pred function.




\end {document}
