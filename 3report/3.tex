\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}

\title {Functional and logic programming lab 3rd report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle
\section{Q.1: 分割コンパイル}
\subsection{}

まず、正常に動作するコードを示す。
  \begin{lstlisting}[caption=正常に動作するコード]
  sort: strSet.cmi strSet.cmo sort.cmo
    ocamlc -o sort strSet.cmo sort.cmo
  strSet.cmi: strSet.mli
      ocamlc -c strSet.mli
  strSet.cmo: strSet.ml
      ocamlc -c strSet.ml
  sort.cmo: sort.ml
      ocamlc -c sort.ml

  clean:
      rm -rf *.cmi *.cmo sort
  \end{lstlisting}

\subsection{}

次に、.cmo fileをインタプリタで使ってみる。いかに出力を表す。
  \begin{lstlisting}[caption=出力]
    #load "strSet.cmo";;
    # StrSet.empty ;;
    - : StrSet.t = <abstr>
    # StrSet.count_sub ;;
    Error: Unbound value StrSet.count_sub
  \end{lstlisting}
strSet.mliに定義していない関数は使えない、すなわち、count\_subはmoduleとなっていない。

このことから、mli fileをコンパイルせずに、.cmo fileを作ると結果が違うこともわかり、実際にそれを試した結果が以下となる。
  \begin{lstlisting}[caption=出力]
    #load "hoge.cmo";;
    # Hoge.count_sub;;
    - : String.t -> int -> String.t list -> int = <fun>
  \end{lstlisting}
cmi fileが自動生成されたが、moduleとして定義できていない。

このとき、ocaml -c hoge.ml を実行するときに、同じ名前のmli file(hoge.mli)が同じdirectory内に存在して、なおかつ.cmi のfileを作成していないとエラーを返すので、その点には注意をして実行する必要がある。

\subsection{}

次にmli fileをコンパイルせずに、makeを行なってみる。
  \begin{lstlisting}[caption=make fileの中身]
    sort: strSet.cmo sort.cmo
        ocamlc -o sort strSet.cmo sort.cmo
    strSet.cmo: strSet.ml
        ocamlc -c strSet.ml
    sort.cmo: sort.ml
        ocamlc -c sort.ml

    clean:
        rm -rf *.cmi *.cmo sort
  \end{lstlisting}

これに対してはエラーを返す。
make: *** No rule to make target `strSet.cmi', needed by `sort'.  Stop.

これはsortで、strSetの関数を使用しようとするが、cmi fileがないので、signitureが定義できず、エラーが起きる。

\subsection{}
sort.cmoを先に作ってみる
  \begin{lstlisting}[caption=make fileの中身]
    sort: sort.cmo strSet.cmi strSet.cmo
      ocamlc -o sort sort.cmo strSet.cmo
    strSet.cmo: strSet.ml
      ocamlc -c strSet.ml
    strSet.cmi: strSet.mli
      ocamlc -c strSet.mli
    sort.cmo: sort.ml
      ocamlc -c sort.ml

    clean:
      rm -rf *.cmi *.cmo sort
  \end{lstlisting}

これもエラーを返す。
make: *** [sort.cmo] Error 2

sort.cmoを作る際に、strSetと言うmoduleを参照するが、参照できないため、エラーを起こしてし
まう。

\subsection{}
リンク時の順番を入れ替えてみる。
  \begin{lstlisting}[caption=make fileの中身]
      sort: strSet.cmi strSet.cmo sort.cmo
        ocamlc -o sort sort.cmo strSet.cmo
      strSet.cmo: strSet.ml
        ocamlc -c strSet.ml
      strSet.cmi: strSet.mli
        ocamlc -c strSet.mli
      sort.cmo: sort.ml
        ocamlc -c sort.ml

      clean:
        rm -rf *.cmi *.cmo sort
  \end{lstlisting}

  File "\_none\_", line 1:
  Error: Required module `StrSet' is unavailable
  make: *** [sort] Error 2

  これも、依存関係に違反しているため、エラーを返す。

\subsection{}
Ocaml Make file をocaml make fileという名前で保存した。





\section{Q.2: スタックの実装}
\subsection{動作例}
"make"を行ったあと、./mainを実行すると7,1と表示される。

\begin{lstlisting}[caption=main.mlの中身の一部]
let s = empty;;
let t = push 5 s;;
Printf.printf "%d\n" (size t);;

let u = push 7 t;;
let v = pop u;;
let w = fst(v);;
Printf.printf "%d\n" (w);;
\end{lstlisting}

このような動作を行い、出力は7と1となっている。

\subsection{考察}
この課題では分割コンパイルを試してみるべく、実装をmain.mlとstack.mlとstack.mliに分けて行うことにした。分割コンパイルの際は、sig - end、 struct - endの中身の部分のみを書くことに注意しなければならなかった。また、コンパイルの順番はQ.1同様注意しなければならなかった。

今回、stack.mlの中身ではlistを使った実装を行った。しかし、このことは、module化しているので、使うユーザーの視点からはわからないものとなっている。

\section{Q.3: functor}
\subsection{動作例}
3.mlをuseする

\begin{lstlisting}[caption=動作例]
let s = Bst.empty;;
val s : Bst.t = <abstr>

let t = Bst.add 1 s;;
val t : Bst.t = <abstr>

let u = Bst.add 2 t;;
val u : Bst.t = <abstr>

let v = Bst.add 5 u;;
val v : Bst.t = <abstr>

let w  = Bst.add 4 v;;
val w : Bst.t = <abstr>

let x = Bst.remove 4 w;;
val x : Bst.t = <abstr>

Bst.count 4 x;;
- : int = 0

# Bst.count 5 x;;
- : int = 1
\end{lstlisting}

\subsection{考察}
二分木を実装した。木の作り方は前回の課題で行った方法と同じvariantを使う方法を用いた。addとcountは愚直に実装するだけであった。
removeについて、消したいノードの下に子のノードが二つあった時にするべきことは右の子の最小値を持ってきて、消したノードの場所に入れることである。
searchminという関数で最小値を探し、その値を再帰呼び出しでremoveするという方法で実装した。

functorは別のmoduleでパラメータ化されるmoduleである。moduleの動作にそぐわないものが入力されたときにエラーを返すことができるようになる。例えばここでは、compareができないものが入力できないようになっている。

\section{Q4: 連想配列}
\subsection{動作例}

\begin{lstlisting}[caption=動作例]
let s = Map.empty;;
val s : 'a Map.t = <abstr>

let t = Map.add 1 "one" s;;
val t : string Map.t = <abstr>

let u = Map.add 2 "two" t;;
val u : string Map.t = <abstr>

let v = Map.add 5 "five" u;;
val v : string Map.t = <abstr>

let w = Map.add 4 "four" v;;
val w : string Map.t = <abstr>

Map.lookup 4 w;;
- : string = "four"

let x = Map.remove 4 w;;
val x : string Map.t = <abstr>

Map.lookup 4 x;;
Exception: Multiset2(T).Eval_error.
\end{lstlisting}

\subsection{考察}
Q.3で二分木を実装していたので、それを用いた実装を行なった。注意した点は、同じkeyの値が入力されたときに上書きするように実装したことである。

\section{Q.5: Matrix module}
\subsection{動作例}
\begin{lstlisting}[caption=Bool matrixの加算]
let x = Boolmatrix.create[[true;false;];[true;false;];];;

let y = Boolmatrix.create [[false; true]; [true; false]];;

let z = Boolmatrix.addition x y;;

Boolmatrix.show z;;

output
- : Bool_ring.t list list = [[true; true]; [true; false]]


\end{lstlisting}
この演算は以下に対応している。

$$\left( \begin{array}{ll}{true} & {false} \\ {true} & {false}\end{array}\right) + \left( \begin{array}{ll}{false} & {true} \\ {true} & {false}\end{array}\right) =
\left( \begin{array}{ll}{true} & {true} \\ {true} & {false}\end{array}\right)$$
この後も同様に、リストのリストとして入力を与える仕様となっている。
\vspace{12pt}
\begin{lstlisting}[caption=Bool matrixとvectorの乗算]
let x = Boolmatrix.create [[true;false;true];[false;true;true;];
[true;true;true];];;

let y = Boolmatrix.create [[true;];[false;];[false;];];;

let z = Boolmatrix.multiplication x y;;

Boolmatrix.show z;;

output
- : Bool_ring.t list list = [[true]; [false]; [true]]

\end{lstlisting}
$$\left( \begin{array}{lll}{true} & {false} &{true} \\ {false} & {true} & {true} \\ {true} & {true} & {true}\end{array}\right) * \left( \begin{array}{l}{true} \\ {false} \\ {false}\end{array}\right) = \left( \begin{array}{lll}{true} &{false} & {true }\end{array}\right)

\vspace{12pt}
\begin{lstlisting}[caption=Bool matrix同士の乗算]
let x = Boolmatrix.create[[true;false;];[false;false;];];;

let y = Boolmatrix.create [[true; true]; [true; true]];;

let z = Boolmatrix.multiplication x y;;

Boolmatrix.show z;;

output
- : Bool_ring.t list list = [[true; true]; [false; false]]
\end{lstlisting}
課題の要件ではないが、行列同士の乗算も実装した。

\vspace{12pt}
\begin{lstlisting}[caption=tropical matrix同士の加算]
let x = Tmatrix.create [[Int 3; Inf; Int 5;];[Int 2;Int 3;Int 4;];
[Int 9;Inf;Int 4;];];;

let y = Tmatrix.create [[Int 2; Inf; Int 5;];[Inf; Int 4; Int 9;];
[Int 12; Int 8; Int 3;];];;

let z = Tmatrix.addition x y;;

Tmatrix.show z;;

output
- : Tropical_ring.t list list =
[[Tropical_ring.Int 2; Tropical_ring.Inf; Tropical_ring.Int 5];
 [Tropical_ring.Int 2; Tropical_ring.Int 3; Tropical_ring.Int 4];
 [Tropical_ring.Int 9; Tropical_ring.Int 8; Tropical_ring.Int 3]]
\end{lstlisting}

\vspace{12pt}
\begin{lstlisting}[caption=tropical matrixとvectorの乗算]
let x = Tmatrix.create [[Int 9; Inf;];[Int 2; Int 3;];];;

let y = Tmatrix.create [[Int 7;] ;[Int 5;];];;

let z = Tmatrix.multiplication x y;;

Tmatrix.show z;;

output
[[Tropical_ring.Int 16]; [Tropical_ring.Int 8]]
\end{lstlisting}

\vspace{12pt}
\begin{lstlisting}[caption=tropical matrix同士の乗算]
let x = Tmatrix.create [[Int 5;Int 2;Inf;];[Int 8;Int 3;Int 7;];
[Inf; Int 5; Int 2;];];;

let y = Tmatrix.create [[Inf; Int 9; Int 5;];[Inf; Int 8; Int 3;];
[Int 3; Int 2; Int 9;];];;

let z = Tmatrix.multiplication x y;;

Tmatrix.show z;;

output
- : Tropical_ring.t list list =
[[Tropical_ring.Inf; Tropical_ring.Int 10; Tropical_ring.Int 5];
 [Tropical_ring.Int 10; Tropical_ring.Int 9; Tropical_ring.Int 6];
 [Tropical_ring.Int 5; Tropical_ring.Int 4; Tropical_ring.Int 8]]
\end{lstlisting}
以上が動作例となる。

\vspace{12pt}
\subsection{考察}

今回は1行n列の行列として横ベクトルを、n行1列の行列として縦ベクトルを、それぞれ扱うこととして実装した。中の実装もリストのリストとして行なった。行列の和や積が定義されない入力が与えられるとエラーが出力されるようになっている。module化しているので、リストのリストとしてユーザーは入力するが、実際の中身がリストのリストとして動いているのかはわからないようになっている。

tropical semi ringの実装については、infを別に定義する必要があったため、variant型を用いて実装を行なった。

\section{Q.6: EQ1}
\subsection{動作例}

\begin{lstlisting}[caption=EQ1の出力]
let c1 = EConstInt (Eq.refl, 1);;
val c1 : int expr = EConstInt ((<fun>, <fun>), 1)

let c2 = EConstInt (Eq.refl, 2);;
val c2 : int expr = EConstInt ((<fun>, <fun>), 2)

let add12 = EAdd (Eq.refl, c1, c2);;
val add12 : int expr =
  EAdd ((<fun>, <fun>), EConstInt ((<fun>, <fun>), 1),
   EConstInt ((<fun>, <fun>), 2))

let ct = EConstBool (Eq.refl, true);;
val ct : bool expr = EConstBool ((<fun>, <fun>), true)

let cif = EIf (ct, add12, c2);;
val cif : int expr =
  EIf (EConstBool ((<fun>, <fun>), true),
   EAdd ((<fun>, <fun>), EConstInt ((<fun>, <fun>), 1),
    EConstInt ((<fun>, <fun>), 2)),
   EConstInt ((<fun>, <fun>), 2))

let c1 = EConstInt (Eq.refl, 1);;
val c1 : int expr = EConstInt ((<fun>, <fun>), 1)

let ct = EConstBool (Eq.refl, true);;
val ct : bool expr = EConstBool ((<fun>, <fun>), true)

let cadd = EAdd (Eq.refl, c1, ct);;
Error: This expression has type bool expr
       but an expression was expected of type int expr
       Type bool is not compatible with type int
\end{lstlisting}

\subsection{考察}

この方法を用いると、型が整合しない式を事前に省くことが可能となる。
前回の式だと、以下の式のようになり、EAddは定義できてしまっている。
\begin{lstlisting}[caption=前回の問5]
# let c1 = EConstInt (1);;
val c1 : expr = EConstInt 1
# let c2 = EConstBool (true);;
val c2 : expr = EConstBool true
# let cadd = EAdd (c1,c2);;
val cadd : expr = EAdd (EConstInt 1, EConstBool true)
\end{lstlisting}
この問題では、Eq moduleを作成することで、式を評価する前に、定義できない式を省くことができるようになっている。


\end {document}
