\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}
\renewcommand{\lstlistingname}{Code}

\title {Functional and logic programming lab 8th report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle

課題１から課題４をkadai1のfolderに、課題５をkadai5のfolderに、課題７をkadai7のfolderに実装した。

\section{Q.1: 再汎単一化子}
\subsection{解答}

(1) $\alpha = Int, \beta = int \rightarrow Int$

(2) 解なし

(3) $\alpha = Int, \beta = Int$

(4) $\alpha_1 = \beta_1 \rightarrow \beta_2, \alpha_2 = \beta_1 \rightarrow \beta_2, \alpha_3 = \beta_1 \rightarrow \beta_2$

(5)解なし

\section{Q.2: ty\_substの定義}
\subsection{実行例}
この実行例は、tySyntax.mlとconstraintSolver.mlのファイルの中身をocaml上で実行させることで確認を行った。
\begin{lstlisting}[caption=動作例]
# ty_subst [(1,TyInt); (2,TyVar(4))] TyInt;;
- : ty = TyInt

# ty_subst [(1,TyInt); (2,TyVar(4))] TyBool;;
- : ty = TyBool

# ty_subst [(1,TyInt); (2,TyVar(4))] (TyVar(2));;
- : ty = TyVar 4

# ty_subst [(1,TyInt); (2,TyVar(4))] (TyFun(TyVar(2), TyInt));;
- : ty = TyFun (TyVar 4, TyInt)

# ty_subst [(1,TyInt); (2,TyVar(4))] (TyFun(TyVar(2), TyVar(1)));;
- : ty = TyFun (TyVar 4, TyInt)

\end{lstlisting}

\subsection{考察}
まず、型を定義する。型の定義は前回のmli fileと同様に行った。また、newvarについては新しい関数が定義されるたびにincrementして、変数の通し番号がかぶら内容にするため、tyvarはint型で定義した。

ty\_subst型の関数の働きは、sigmaとtを受け取って、tがもし、sigmaという代入するリストの中に入っていれば、代入を行うという働きである。よって、tがty型のなにかによって場合分けをする。この動きはスライドの型代入の部分に詳しく記載されている。tがVIntやVBoolであった時はそのまま返す。

tが変数であった場合は、その変数に対して代入が起こるか否かをsigmaを探索して確認する。そのための関数が、lookupである。lookupによって、見つかった場合は代入を行い、見つからなかった場合は元の変数をそのまま返す。

tが関数であった場合には、関数の引数、返り値のそれぞれについてty\_substを行えば良い。

\section{Q:3 代入を合成する関数}

\subsection{動作例}
\begin{lstlisting}[caption=動作例]
# let sig1 = [(1,TyInt);(2,TyVar(4))];;

# let sig2 = [(5,TyBool);(9,TyVar(1));(3,TyBool);(6,TyFun(TyInt,TyBool))];;

# compose sig1 sig2;;
- : (tyvar * ty) list =
[(1, TyInt); (2, TyVar 4); (5, TyBool); (9, TyInt); (3, TyBool);
(6, TyFun (TyInt, TyBool))]

\end{lstlisting}

\subsection{考察}
compose関数を定義する。compose関数の大きな流れとしては、sig1とsig2を受け取り、sig2の代入した後について、sig1の代入を行うという、list\_subst関数を定義する。そして、その関数を適用した結果をsubstitutedとして、sig1の代入前がsubstitutedの代入前と被っていたら削除するという関数、list\_eraseを定義する。

まず一つ目の関数は、list\_subst関数である。この関数は、listに対してsubstitutionを行う関数である。ty\_substでは、ty型に対してしか代入操作が行えなかったため、sig2をmatch文で分解する。sig2で$\alpha \rightarrow \beta $、sig1で$\beta \rightarrow \gamma $となっているものを$\alpha \rightarrow \gamma$にする操作であるので、それ通りに実装する。

その次の関数は、list\_eraseである。この関数は、sig2とsig1の競合をなくす関数である。この操作はlist\_subst関数を行ったあとでは必要ないが、一応実装した。この関数のためにfirst\_checkという関数を定義した。これは、先頭要素を順に見て行って存在すればtrue,存在しなければfalseを返す関数である。この関数を用いて、substitutedの中に$\alpha \rightarrow \beta $があり、sig1の中に$\alpha \rightarrow \gamma$がある時の、$\alpha \rightarrow \gamma$を削除する作業を行う。

\section{Q:4 単一化を行う関数}

\subsection{動作例}
\begin{lstlisting}[caption=動作例]
unify [(TyVar(1),TyInt);(TyVar(2), TyFun(TyVar(1),TyVar(1)))];;
- : (tyvar * ty) list = [(2, TyFun (TyInt, TyInt)); (1, TyInt)]

unify [(TyInt,TyFun(TyInt,TyVar(1)))];;
Exception: TyError.

unify [(TyFun(TyInt,TyInt),(TyFun(TyVar(1),TyVar(2))))];;
- : (tyvar * ty) list = [(1, TyInt); (2, TyInt)]

unify [(TyFun (TyVar(1),TyVar(2) ),(TyFun(TyVar(2),TyVar(3) )));
(TyVar(3), TyFun (TyVar(4),TyVar(5)))];;
- : (tyvar * ty) list =
[(3, TyFun (TyVar 4, TyVar 5)); (1, TyFun (TyVar 4, TyVar 5));
(2, TyFun (TyVar 4, TyVar 5))]

unify [(TyFun (TyVar(1),TyVar(1)) , TyFun (TyVar(2), TyVar(3)));
(TyVar(3), TyFun(TyInt,TyVar(2)))];;
Exception: TyError.
\end{lstlisting}

これはQ.1の結果と等しくなっており、正しい。

\subsection{考察}
まず、前回も実装したunion関数を定義した。そのために、setin関数も定義しているが、この関数はunion以外で使わないため、説明は割愛する。union関数は、和集合をとる関数である。

次にinclude\_check関数を定義した。これは、スライドの単一化アルゴリズムにおける、tはalphaを含まないにあたる部分である。含んでいればエラーが出るようにしている。

subst関数は、ty\_subst関数はリストに対する代入が行えないため定義した関数である。

本題のunify関数に入る。unify関数は再帰関数で記述する。constには制約が入り、制約の一つ一つについて見ていく。

Int = Int やBool = Boolは自明であるので覗く。

関数がきた場合は、引数同士、返り値どうしが等しいという式に書き直し、残りの制約とunionをとる。

変数が来た場合は、スライド通りに、compose関数とsubst関数を用いて評価を行う。この時tは\alphaを含まないことに注意して、include\_checkを行う必要がある。そこでエラーが出た場合はraise errorすれば良い。

以上の形におさまらないものについてはerrorをraiseすれば良い。

\section{let多層}
\subsection{実行例}
\begin{lstlisting}[caption=動作例]
# let f = fun x -> x in if f true then f 1 else 3;;
int
- = 1
# fun f -> fun x -> let g = f in if g true then g 1 else 3;;
Error = Unmatched type
# let apply = fun f -> fun x -> let g = f in if g true then g 1 else 3;;
Error = Unmatched type
# let rec apply x = let g = apply in if g true then g 1 else 3;;
Error = Unmatched type
\end{lstlisting}

\subsection{考察}
\subsubsection{変数}
まず、infer\_exprの変数の処理についてかく。まず型環境を見て、型変数に対応する型スキームを取ってくる。これについて、instantiateという関数を実行する。instantiate関数は、bindされている変数に新しい変数を割り当てて、それぞれに代入する操作を行う関数である。create\_substitution関数で、新しく作った変数への割り当てを行う代入関数を作っている。

\subsubsection{let in文}
let in文についてはスライド通りの流れで実装を行なった。

let in文のスライドを実装するにあたって必要になった関数の説明を順にしていく。

\vspace{12pt}

まず、get\_type\_vars関数の実装を行なった。これはty型から変数のリストを受け取る関数である。

次に、comp\_list\_list関数の説明をする。この関数は、リストを二つ受け取り、(li1,li2とする)、li1に含まれていて、li2に含まれていない要素のリストを返す関数である。

\vspace{12pt}

$\Delta = \Gamma \sigma $をするにあたり、env\_substという関数を実装した。ここで代入を行うのは、$\forall$でbindされていないものについてであることに注意する。$\Gamma$一つ一つに対して、代入を行なっていくために、一つに対しての代入を行う関数、env\_subst\_hitotuを定義した。その関数の中では、まず、$\Gamma$の要素のうち、代入されるべきもののリストをlets\_substituteにいれている。sigmaをその代入するべき変数のみにしたものをsigma2とする。この操作をしないと、bindされている変数についても代入が行われてしまう可能性がある。そしてそれを用いて代入を行えば良い。

\vspace{12pt}

次に、スライドのPを定義する。Pはs1に現れて、$\Delta$に現れない型変数の集合である。
一方のlistに含まれていてもう一方に含まれていない要素のlistはcomp\_list\_listを用いてかけるので、comp\_list\_listを用いてかく。この時、s1に含まれる変数は、get\_type\_varsでlistとして受け取ることができる。create\_pでPに含まれる自由な変数を取ってきている。

create\_Pについて、これは型環境から変数のリストを取ってくる関数である。よって一つ一つのschemeについて、pick\_var\_from\_schemaというschemaから変数を取ってくる関数を用いて、変数のリストを取ってきている。

これによってgeneralizeによって、$\forall P. s_1$が作ることができた。

スライド通りにnewtenvを上で作ったgeneralizeを用いて定義して、v2を評価すれば、let in文については完成する。

\vspace{12pt}

あとは型環境を(name * type\_schema)になるように型が整合しない部分を変えていけば完成する。

\section{Q.6: Occurance check}
出現検査がなければ変数が無限の項を持たなければならなくなり、項は有限と仮定したことに矛盾する。
その例を以下に挙げる。

$\{\alpha = int \rightarrow int \rightarrow \alpha, \beta \rightarrow \alpha \rightarrow int\}$をunificationすると、

$\{\alpha = int \rightarrow int \rightarrow \alpha, \beta = int \rightarrow int \rightarrow \alpha \rightarrow int \}$となり、それをもう一度unificationすると、

$\{\alpha = int \rightarrow int \rightarrow \alpha, \beta = int \rightarrow int \rightarrow int \rightarrow int \rightarrow \alpha \rightarrow int \}$となる。

これは確かに、unificationを繰り返すことで無限の項となってしまう例である。

出現検査をしないで単一化することは、cyclic structuresを考えていることに相当する。

\section{Q.7: 繰り返し評価}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
# let x = fun x -> (x,x) in
let x = fun y -> x (x y) in
let x = fun y -> x (x y) in
let x = fun y -> x (x y) in
let x = fun y -> x (x y) in
let x = fun y -> x (x y) in
x (fun x -> x);;
a39->a39
- = 2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*<fun>

# let x = fun x -> (x,x) in
let x = fun y -> x (x y) in
let x = fun y -> x (x y) in
x (fun x -> x);;
a18->a18
- = 2*2*2*<fun>
\end{lstlisting}

\subsection{考察}
まず、今回の型推論の難しいポイントとして、型推論が終わりきらないということがある。これが原因となって、型推論や評価が終わらないということになってしまっている。今回は同じexpressionを評価する際に、片方だけを評価するという方法を取ることで、評価・推論の時間を削減した。まず、そのために、考えられる方法としては、一定長のリストに評価したものの結果をためておく方法と、Pairの両辺に同じexpressionがきたら、評価を一回だけにする方法が考えられる。前者の方が一般性を保持しているが、今回の課題要件を満たすには後者で十分であるため、後者で実装した。

今回の実装ではeval\_exprで繰り返し(同じexpression)の起こった回数を数えて、infer\_exprでは繰り返しの最小単位を返すという実装を行った。
型推論の部分では、繰り返しの最小単位の型を返せば良い。そのためにVRepeatという新しい型を導入した。infer\_exprのEPairの部分で、pairの前後の入力が等しければ、TyRepeatという型に入れる。また、constraintSolverの部分もそれに応じて変更した。これによって、型の出力は一つ分になる。

また、eval\_exprの部分で、繰り返し回数を数える。新しくvalueのvariantにVRepeatという新しい型を追加する。新しい型には繰り返す型と繰り返す回数が記載されている。ここでsyntax.mlのprint\_valueでの出力の際繰り返されている回数分2*で出力すれば良い。そうすることで、実際であればconsole内に収まらない型を省略して書くことができる。



\section{Q.8: 論文}
Conor McBride, "First-order unification by structural recursion", Journal of Functional Programming, 13(6), 1061—1075, 2003の要約と感想
\subsection{要約}
この論文は、単一化アルゴリズムの停止性を証明する方法として、従来と異なる方法を、データの型を工夫することで実現している。ここでは、データ型をInductive なデータにすることで構造帰納法を用いれるようにしている。この論文での構造帰納法とは、型を階層化して、Term nと記述されている、(a set of n variables)を表すものに関する帰納法を用いることである。筆者は、自身の定義したdatatypesのdeduction styleな記述方法で、match文などの基本構文の記述を説明し、その後、substitution,Occurance check, unificationについて説明している。

\subsection{感想}
単一化アルゴリズムの停止性の証明は別のサイトに書いているようであったが、そこまで読むことができなかったため、また機会があれば読んでみたいと感じた。










\end{document}
