\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}
\renewcommand{\lstlistingname}{Code}

\title {Functional and logic programming lab 6th report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle
\section{Q1: fun文}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # fun x -> x + 2;;
  - = <fun>
  # (fun x -> x + 2) 2;;
  - = 4
\end{lstlisting}

\subsection{考察}
ここでは関数が定義できるようにすることと、関数を適応できるようにすることを行った。

例題で行ったように、VFunをname * expr * (name * value) listの型で定義する。

この問題では主に、eval.mlの部分を変更する。

\subsubsection{関数の適用}
この問題ではこちらから考えた方が考えやすいので、こちらから考察する。
関数の適用についてはEAppを実装すれば良い。
まず、関数と引数のexprを評価する。そのあとに、関数評価をする。ここで、関数を評価する環境は関数を宣言した時の環境であることに注意する。評価は、変数の宣言と同様のことを行った環境で評価するだけで良い。

\subsubsection{関数の宣言}
関数の宣言については、EFunの部分について実装を行えば良い。EFunについて評価が行われたあとは、CExpにいくことが構文木(parser.mly)からわかる。今はfunの宣言ができるようにすればいいので、型を合わせるだけで良い。

最後に、printできるようにするために、VFunが来た時に"\<fun\>"を出力するというコードを書けば良い。


\section{Q2: 再帰関数の実装（参照を用いた場合）}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let rec fact n = if n = 0 then 1 else fact ( n - 1 ) * n;;
  - = <fun>
  # fact 3;;
  - = 6
  # let rec fact n = if n = 0 then 1 else fact ( n - 1 ) * n in fact 3;;
  - = 6
\end{lstlisting}

\subsection{考察}
まず、再帰関数closureの生成を行う。これはeval.mlのELetRecで行われている。まず、ダミーの環境oenvを作り、v = VFun (x,e1,oenv)として（この時点ではoenvは[ ]のポインタ）、oenv := extend f v env;とeval\_expr (extend f v env) e2を実行する。oenv := extend f v env;によって、vの中のoenvが指す内容も変化する。なぜなら、oenvはreferenceを用いて宣言しているからである。これによって再帰の構造ができた。

次に再帰関数の評価についてみる。再帰関数の評価はEAppで行われている。評価の時には再帰関数の引数を対応させるだけで良い。なぜなら、oenvに再帰関数の環境が入っているからである。これはQ4でみる方法と大きく違う点である。

\section{Q3: 相互再帰}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let rec even n =
    if n = 0 then true
    else odd (n-1)
    and
    odd n =
    if n = 0 then false
    else even (n-1)
  ;;
    - = <fun>
  # even 2;;
    - = true
  # odd 5;;
    - = true
  # even 3;;
    - = false
  # odd 4;;
    - = false

  # let rec even n =
    if n = 0 then true
    else odd (n-1)
    and
    odd n =
    if n = 0 then false
    else even (n-1)
    in
    even 2;;
    - = true
\end{lstlisting}

\subsection{考察}
参照を用いて循環的closureを作成する方法を用いて実装した。
循環的closureを作成するには三つのステップがある。まず、ダミー環境のoenvを作り、次に、各宣言につき、closureを作り、最後に、oenvの環境を(f1,v1)::(f2,v2):: ... ::(fn,vn)::envに書き換えれば良い。

まず、宣言を順番に評価できるように、listを順に評価できるような関数をmatch文で作る。それがeval.mlの中のupdate関数に相当する。update関数で行いたいことはoenvを書き換えていくことである。参照を用いているため、v1から評価したとして、v1の評価直後(v1 = VFun (x1, e1, oenv))は、vnの環境が入っていないように見える。だが、参照を用いているため、vnの評価によって、oenvが書き換えられると、その影響を受けることになる。

こうすることで、相互再帰に対応できるようになる。


\section{Q4:　関数適用の工夫を用いる方法}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let rec fact n = if n = 0 then 1 else fact ( n - 1 ) * n;;
  - = <fun>
  # let rec fact n = if n = 0 then 1 else fact ( n - 1 ) * n in fact 4;;
  - = 24
\end{lstlisting}

\subsection{考察}
まず、再帰関数closureの生成を行う。この実装方法では、生成の部分ではなく、評価の時に複雑な処理を行うことで再帰関数を実現しているため、生成の部分はとてもシンプルである。具体的には、元々の環境に、関数名fと、新しく作ったvalue型VRecFunの対応を付け加えるだけである。

再帰関数の関数適用は、EAppで行われる。
再帰関数に対して、VRecFunを対応づけた環境に、変数の対応づけを行う

env2 =　extend x v2　(extend f (VRecFun(f,x,e,oenv)) oenv)

そして、この環境の下で評価を行う。

評価をその場で行わない関数宣言は、CRetDeclで行った。これは、この考察の最初に述べた再帰関数closureの生成と同じことをしている。

\section{Q5: 関数定義のための略記法}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
# ( fun x y z -> x * y - z );;
- = <fun>
#  ( fun x y z -> x * y - z ) 5 4 2;;
- = 18
# let f x y = x + y in f 5 2;;
- = 7
\end{lstlisting}

\subsection{考察}
1をベースに実装を行った。
引数をリストにすれば良い。

引数をリストにするために、parser.mlyでlvarとlexprを定義した。
varをlvarに変えたため、CDeclも変更することになった。CDeclについては、変数が複数のリストを受け取りたくないので、複数受け取った場合はエラーが起きるようにした。

大きく変更すべきなのは、EAppとELetである。

まず、EAppについては、関数適用時の引数の一つ一つを対応づけていくという形を取れば良い。変数はリストで受け取り、変数に代入するexpressionもリストで受け取っている。そのリストをうまく処理する関数がenvappとして定義されているものである。envappは１で行ったことと同じことをリストで行うだけである。

次に、ELetについて。ELetは変数をリストとして受け取るが、その変数リストの第一要素は関数名である。なので、第一要素とそれ以外に分けて、VFunの然るべき場所にそれぞれ入れれば良い。環境、(extend f (VFun(rest,e2,env)) env)でIN以降のexpressionを評価することになる。





\section{Q6: 値の再帰的定義を使った再帰関数の実装}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let rec fact n = if n = 0 then 1 else n * fact (n-1);;
  - = <fun>
  # let rec fact2 n = if n = 0 then 1 else n * fact (n-1);;
  - = <fun>
  # let a = 10;;
  a = 10
  # let rec fact3 n = if n = 0 then a else n * fact3 (n-1);;
  - = <fun>
  # fact3 3;;
  - = 60
  # let a = 3;;
  a = 3
  # fact3 2;;
  - = 20
  # a;;
  - = 3
\end{lstlisting}

\subsection{考察}
let rec oenv = (f, VFun(x,e1,oenv)) :: envとして、oenvを定義して、その環境で関数の適用を行えば良い。

このコードであれば、oenvにはfとVFunの対応関係が入っていて、再帰できるようになっている。

\section{Q7: 動的束縛の関数定義}
\subsection{動作例}
\begin{lstlisting}[caption=動作例]
  # let a = 10;;
  a = 10
  # let f = (dfun x -> x + a);;
  f = <fun>
  # let a = 20;;
  a = 20
  # f 10;;
  - = 30
  # let rec fact n = if n = 0 then 1 else n * fact (n-1);;
  - = <fun>
  # fact 5;;
  - = 120
\end{lstlisting}
\subsection{考察}

まず、動的束縛の関数を定義する。そのためのDVFunを作った。
DVFunの関数適用は eval\_expr (extend x v2 env) e　のように行い、関数定義時の環境ではなく、関数適用時の環境をベースに行うことに注意する。この工夫によって動的束縛の関数が書ける。

次に、動的束縛を用いて、再帰関数を定義する。動的束縛の場合、関数適応時の環境で関数を評価するので、newenv = extend f (DVFun(x,e1)) envとした、newenvの環境では、いつでも再帰関数の評価を行うことができる。それは DVFun (x, e) $\rightarrow$　eval\_expr (extend x v2 env) eの部分から明らかである。(動的束縛では関数定義の環境(fが入っていない)に依存しない。)

一部の言語では動的束縛が用いられている。再帰関数もletrecなどと区別して書く必要がない。静的束縛を用いるか動的束縛を用いるかは言語によって異なる。それは言語デザインの段階で決まっていて、それはその言語の目的に依存している。pythonで今回のQ7と同様のコードを実装すると同じ結果となる。



\end{document}
