2.mlを実行して、
simple test_bananaをする

3.mlについて

>==の関数について
fst(x)は前までの計算結果
f (fst(x))


xはfib(n-2)が渡されていて、それに対して、関数を適用する。
その関数っていうのは、fib(n-2)を受け取って、fib(n)を計算する関数である。
ちなみに、関数はtype'a mを返すもの。


let x = fib(n-2) in
let y = fin(n-1) in
return (x + y)


遡るという解釈が間違っていて、関数適応するときに記録するイメージ
関数の適応(>>=)では、関数を適応した結果

関数適応して、結果をもらう（第一引数）
結果さんのlogをもらう（第二引数）

 nこめの計算を>>=でしたいときに引数はn-1こめの結果が入っていて、


(f 3)が評価され、(fun x->以後が評価され、そのあとに>>=が評価されるが、
(fun x->の中身に入って行く。

returnが評価されるまではfを遡って行く（深いところに行く）
最深部までいったら9と""が返されて、
一番最後の>>=の
  (fst(f (fst(x))),snd(x)^snd(f(fst(x))))
の部分の評価ができるようになる。

違和感なのは、9が評価されるのは行きがけなのに、logの評価は帰りがけになっていること。


https://blog.janestreet.com/bind-without-tears/
これが発展の参考文献
