\documentclass[uplatex,12pt]{jsarticle}
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\lstset{basicstyle=\small,style=myCustomMatlabStyle}

\title {Functional and logic programming lab 4th report}
\date{}
\begin{document}
\author{Yoshiki Fujiwara, 05-191023}
\maketitle
\section{Q.1: 失敗しうる計算とmonad}
\subsection{動作例}
  \begin{lstlisting}[caption=動作例]
    # let table = [("x", 6); ("y", 0); ("z", 2)];;;;
    val table : (string * int) list = [("x", 6); ("y", 0); ("z", 2)]
    # lookupDiv "x" "y" table;;
    - : int m = Err "Division by Zero"
    # lookupDiv "x" "z" table;;
    - : int m = Ok 3
    # lookupDiv "x" "b" table;;
    - : int m = Err "Not found: b"
    # lookupDiv "a" "z" table;;
    - : int m = Err "Not found: a"
  \end{lstlisting}

\subsection{考察}
この問題では資料中の例１に対応する失敗しうる計算についてのmonadの実装を行なった。

\section{Q.2: 覆面算}
\subsection{動作例}
  \begin{lstlisting}[caption=動作例]
  # simple test_banana;;
  - : (int * int * int * int * int) list =
  [(1, 2, 0, 4, 4); (2, 4, 0, 8, 8); (2, 5, 0, 1, 0); (3, 7, 0, 5, 4);
  (4, 9, 0, 9, 8); (5, 0, 1, 0, 0); (6, 2, 1, 4, 4); (7, 4, 1, 8, 8);
  (7, 5, 1, 1, 0); (8, 7, 1, 5, 4); (9, 9, 1, 9, 8); (0, 0, 0, 0, 0)]
  \end{lstlisting}

  \begin{lstlisting}[caption=動作例]
  # complex test_money;;
  - : (int * int * int * int * int * int * int * int) list =
  [(9, 5, 6, 7, 1, 0, 8, 2)]
  \end{lstlisting}

\subsection{考察}
非決定性monadを用いて実装を行なった。
\subsubsection{ばなな + ばなな = しなもん}
この計算については、異なる文字に同じ数字を使ってもよく、先頭に0が割り当てられても良いと言う条件の素で行なった。追加で制約を加えることなく実装した。
\subsubsection{SEND + MORE = MONEY}
この計算については、合計8文字あり、時間のかかる計算となるため、異なる文字を使うことと、先頭に0が割り当てられないようにすることの二つの工夫を行なった。removeと言う関数は、リストから複数の数字を削除する関数である。


\section{Q3: Writer monad}
\subsection{動作例}
  \begin{lstlisting}[caption=動作例]
    # let f x = (x+1, "call f("^(string_of_int x)^"), ");;
    val f : int -> int * string = <fun>
    # let g x = (2*x, "call g("^(string_of_int x)^"), ");;
    val g : int -> int * string = <fun>
    # (f 3) >>= (fun a ->
      (g a) >>= (fun b ->
      (f b) >>= (fun c ->
        return c)));;
    - : int * string = (9, "call f(3), call g(4), call f(8), ")
  \end{lstlisting}

\subsection{考察}
以下では、fibonacci数列にこのmonadを適応したときについての考察である。
$>>$=は二項演算子なので、(第一引数)$>>=$(第二引数)の順で書かれる。

(fib (n-2)) $>>=$ (fun x $->$
    (fib (n-1)) $>>=$ (fun y $->$
    return (x + y))))
の部分について、考える。初めの$>>=$について、
(fib (n-2))が第一引数、(fun x以下)が第二引数となる。

(fun x以下)の部分は、「xを受け取って、fib(n-1)の値を足した結果」と、「xを受け取って、これまでの適応の履歴」の二つをpairで返す関数である。

そのことから、$>>=$の挙動を考えることができる。

fst(f(fst(x)))が、fib(n)となるので、pairの第一要素には、これを返せばよく、

snd(x)がfib(n-2)までの関数適応の履歴、snd(f(fst(x)))が、これ以降の関数適応についてなので、
snd(x)とsnd(f(fst(x)))を繋げたものを、pairの第二要素として返す。

\vspace{12pt}

授業でおっしゃっていたようにlet文にして考えると、fibonacci数列の値を渡すpair第一要素の部分は直感に従う。

type 'amで定義したpairの第二要素の見方が、難しいポイントであった。




\section{Q4: Memo fibonacci}
\subsection{動作例}
  \begin{lstlisting}[caption=動作例]
    # runMemo(fib(80));;
    - : int = 23416728348467685
  \end{lstlisting}

\subsection{考察}
まず、ここで行いたいのは参照の動作であるということに着目する。

参照についてmonadの操作を行うときは、

(参照の古い値) $\rightarrow$ ((返り値)*(参照の新しい値))という風に書くというのは、演習資料に載っている。

それに従い、type 'amを定義すると以下のようになる。
$$(('a*'a)list -> ('a * ('a*'a)list))$$

次に、$>>=$の部分については、演習資料のものと同じで良い。なぜなら型が変化しただけで、参照の操作に対するmonadの形は変わらないためである。

ここで、type 'am が関数の形になっていることに注意すると、return関数の中身も自然に決まる。

ポイントは、runMemo関数は計算を走らせるためのトリガーとなっていて、memo関数は、すでに計算されていれば値を取り出し、されていなければ、計算を行う関数であるということである。

この使い分けがどこでわかるのかというと、型を見るとわかる。

runMemo関数には、'a m型しか渡されておらず、メモの参照を行うには、厳しいであろうと考えることができる。また、runMemo関数は、fib関数の中に現れないため、「すでに計算されていれば」、という工夫を行うことが難しそうであると気づく。よって上記の関数の使い分けに至る。

memo関数については、すでに計算されていれば値を取り出し、されていなければ、計算を行えば良い。そのため、match文で場合分けを行うことになる。

fib関数を使う部分は、値がなかった時であり、コードの中の19行目、

   [] $\rightarrow$ let y = f n z in (fst(y), snd(y) @ [(n,fst(y))])

に相当する。
その際に、f n zの計算の中で行なった関数についてもmemoが必要であるため、

[] $\rightarrow$ let y = f n z in (fst(y), z @ [(n,z)])

としてはならないことに注意する。

この工夫によって関数適応の回数を減らすことができるというのが、この問題のポイントであった。

\section{Q5: monad}
\subsection{実行例}
今回はmonadの使用例として、与えられた数以下のピタゴラス数を計算するコードを書いた。

行なったことは非決定性monadだが授業で行なったリストmonadの実装とは異なる実装をしているため、課題要件を満たしていると考えた。実際、monad則を満たす、他の型を作ったことになっている。
  \begin{lstlisting}[caption=動作例]
    let () =
      (pythagoras 13)
        (fun (a, b, c) -> Printf.printf "%d %d %d\n" a b c)
  \end{lstlisting}
  \begin{lstlisting}[caption=出力例]
    3 4 5
    5 12 13
    6 8 10
  \end{lstlisting}

\subsection{考察}
ここで、定義したmonadを見てみると、確かにmonad則を満たしている。

コードの中で型の定義として重要な部分を下に示したおく。
  \begin{lstlisting}[caption=コードの中身]
    type 'a m = ('a -> unit) -> unit

    let (>>=) : ('a m -> ('a -> 'b m) -> 'b m) =
    (fun a b c -> a (fun z -> b z c))

    let return : ('a -> 'a m) = (fun a b -> b a)
  \end{lstlisting}

ここからは、実装した関数の説明に入る。

guard 関数は、条件を満たしていれば、return () (この型はunit m型)、満たしていなければ、(fun _ -> ())を返す関数である。


uptoという関数は、授業で扱った非決定性monadのリストの部分に相当している。

第一引数の数字から初めて、第二引数の数字未満の間、関数を適応するという関数である。
すなわち、第一引数以上、第二引数未満の数字が考慮されるようになる。これは、実現したい非決定性に他ならない。

関数適応は、unfoldの中身がわかりやすく、なぜ1ずつ足されて実行されるのかわかる。
実際、$ Some (x, s) ->$ (f x ; unfold g s f)のようになっており、sにはx+1の値が入っているので、順に調べられていく。


最後の実行の部分は、
  \begin{lstlisting}[caption=実行部分の型]
    # (fun (a, b, c) -> Printf.printf "%d %d %d\n" a b c);;
    - : int * int * int -> unit = <fun>
    # pythagoras n;;
    - : (int * int * int) m = <fun>
  \end{lstlisting}
となっており、unitの部分が出力される。



\end {document}
